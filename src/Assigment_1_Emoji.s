.data 
# 16x16 Emoji sprite - each .word is a pixel with its color
Emoji_sprite:
    .word 0x00FFFFFF, 0x00FFFFFF, 0x00FFFFFF, 0x00FFFFFF, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00FFFFFF, 0x00FFFFFF, 0x00FFFFFF, 0x00FFFFFF, 0x00FFFFFF
.word 0x00FFFFFF, 0x00FFFFFF, 0x00000000, 0x00000000, 0x00c7d4e1, 0x00e2e5e7, 0x00e2e5e7, 0x00e2e5e7, 0x00e2e5e7, 0x00e2e5e7, 0x00c7d4e1, 0x00000000, 0x00000000, 0x00FFFFFF, 0x00FFFFFF, 0x00FFFFFF
.word 0x00FFFFFF, 0x00000000, 0x00c7d4e1, 0x00e2e5e7, 0x00e2e5e7, 0x00e2e5e7, 0x00e2e5e7, 0x00e2e5e7, 0x00e2e5e7, 0x00e2e5e7, 0x00e2e5e7, 0x00e2e5e7, 0x00c7d4e1, 0x00000000, 0x00FFFFFF, 0x00FFFFFF
.word 0x00FFFFFF, 0x00000000, 0x00e2e5e7, 0x00e2e5e7, 0x00e2e5e7, 0x00e2e5e7, 0x00c7d4e1, 0x00e2e5e7, 0x00e2e5e7, 0x00c7d4e1, 0x00e2e5e7, 0x00e2e5e7, 0x00e2e5e7, 0x00000000, 0x00FFFFFF, 0x00FFFFFF
.word 0x00000000, 0x00c7d4e1, 0x00e2e5e7, 0x00e2e5e7, 0x00c7d4e1, 0x00c7d4e1, 0x00e2e5e7, 0x00e2e5e7, 0x00e2e5e7, 0x00e2e5e7, 0x00c7d4e1, 0x00c7d4e1, 0x00e2e5e7, 0x00c7d4e1, 0x00000000, 0x00FFFFFF
.word 0x00000000, 0x00e2e5e7, 0x00e2e5e7, 0x00e2e5e7, 0x00000000, 0x00000000, 0x00000000, 0x00e2e5e7, 0x00e2e5e7, 0x00000000, 0x00000000, 0x00000000, 0x00e2e5e7, 0x00e2e5e7, 0x00000000, 0x00FFFFFF
.word 0x00000000, 0x00e2e5e7, 0x00e2e5e7, 0x00e2e5e7, 0x00488bd4, 0x00488bd4, 0x00000000, 0x00e2e5e7, 0x00e2e5e7, 0x00000000, 0x00488bd4, 0x00488bd4, 0x00e2e5e7, 0x00e2e5e7, 0x00000000, 0x00FFFFFF
.word 0x00000000, 0x00e2e5e7, 0x00e2e5e7, 0x00e2e5e7, 0x0078d7ff, 0x0078d7ff, 0x00e2e5e7, 0x00e2e5e7, 0x00e2e5e7, 0x00e2e5e7, 0x0078d7ff, 0x0078d7ff, 0x00e2e5e7, 0x00e2e5e7, 0x00000000, 0x00FFFFFF
.word 0x00000000, 0x00e2e5e7, 0x00e2e5e7, 0x00e2e5e7, 0x0078d7ff, 0x00e2e5e7, 0x00e2e5e7, 0x00e2e5e7, 0x00e2e5e7, 0x00e2e5e7, 0x00e2e5e7, 0x0078d7ff, 0x00e2e5e7, 0x00e2e5e7, 0x00000000, 0x00FFFFFF
.word 0x00000000, 0x00e2e5e7, 0x00e2e5e7, 0x00e2e5e7, 0x00e2e5e7, 0x00e2e5e7, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00e2e5e7, 0x00e2e5e7, 0x00e2e5e7, 0x00c7d4e1, 0x00000000, 0x00FFFFFF
.word 0x00000000, 0x00c7d4e1, 0x00e2e5e7, 0x00e2e5e7, 0x00e2e5e7, 0x00000000, 0x00c7d4e1, 0x00e2e5e7, 0x00e2e5e7, 0x00c7d4e1, 0x00000000, 0x00e2e5e7, 0x00e2e5e7, 0x00000000, 0x00FFFFFF, 0x00FFFFFF
.word 0x00FFFFFF, 0x00000000, 0x00c7d4e1, 0x00e2e5e7, 0x00e2e5e7, 0x00FFFFFF, 0x00e2e5e7, 0x00e2e5e7, 0x00e2e5e7, 0x00e2e5e7, 0x00e2e5e7, 0x00e2e5e7, 0x00c7d4e1, 0x00000000, 0x00FFFFFF, 0x00FFFFFF
.word 0x00FFFFFF, 0x00000000, 0x00928fb8, 0x00c7d4e1, 0x00e2e5e7, 0x00e2e5e7, 0x00e2e5e7, 0x00e2e5e7, 0x00e2e5e7, 0x00e2e5e7, 0x00c7d4e1, 0x00000000, 0x00000000, 0x00FFFFFF, 0x00FFFFFF, 0x00FFFFFF
.word 0x00FFFFFF, 0x00FFFFFF, 0x00000000, 0x00c7d4e1, 0x00e2e5e7, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00FFFFFF, 0x00FFFFFF, 0x00FFFFFF, 0x00FFFFFF, 0x00FFFFFF
.word 0x00FFFFFF, 0x00FFFFFF, 0x00000000, 0x00928fb8, 0x00000000, 0x00FFFFFF, 0x00FFFFFF, 0x00FFFFFF, 0x00FFFFFF, 0x00FFFFFF, 0x00FFFFFF, 0x00FFFFFF, 0x00FFFFFF, 0x00FFFFFF, 0x00FFFFFF, 0x00FFFFFF
.word 0x00FFFFFF, 0x00FFFFFF, 0x00000000, 0x00000000, 0x00FFFFFF, 0x00FFFFFF, 0x00FFFFFF, 0x00FFFFFF, 0x00FFFFFF, 0x00FFFFFF, 0x00FFFFFF, 0x00FFFFFF, 0x00FFFFFF, 0x00FFFFFF, 0x00FFFFFF, 0x00FFFFFF

# Position variables
emoji_x: .word 5      # initial X position
emoji_y: .word 5      # initial Y position 
prev_x:  .word 5      # previous X position for erasing
prev_y:  .word 5      # previous Y position for erasing

.text

main:
    # LED matrix configuration
    li s0, LED_MATRIX_0_BASE
    li s1, LED_MATRIX_0_WIDTH
    li s2, LED_MATRIX_0_HEIGHT
    li s5, LED_MATRIX_0_SIZE
    add s6, s5, s0          # matrix limit
    la s7, Emoji_sprite
    
    # Clear screen at the start
    mv a0, s0
    li a1, 0x00FFFFFF       # white color
clear_screen:
    sw a1, 0(a0)
    addi a0, a0, 4
    bne a0, s6, clear_screen

    # Draw emoji at initial position [5,5]
    li t3, 5                # x = 5
    li t4, 5                # y = 5
    li s8, 0                # row
initial_draw:
    li s9, 0                # column
initial_row:
    # pos = base + ((y+row)*width + (x+col))*4
    add t5, t4, s8
    mul t5, t5, s1
    add t6, t3, s9
    add t5, t5, t6
    slli t5, t5, 2
    add t5, s0, t5
    
    # sprite offset
    slli t6, s8, 4
    add t6, t6, s9
    slli t6, t6, 2
    add t6, s7, t6

    lw t0, 0(t6)
    sw t0, 0(t5)

    addi s9, s9, 1
    li t6, 16
    bne s9, t6, initial_row

    addi s8, s8, 1
    li t6, 16
    bne s8, t6, initial_draw

main_loop:
    # Read D-pad inputs (horizontal and vertical)
    lw t0, D_PAD_0_LEFT      # LEFT pressed?
    lw t1, D_PAD_0_RIGHT     # RIGHT pressed?
    lw t2, D_PAD_0_UP        # UP pressed?
    lw t3, D_PAD_0_DOWN      # DOWN pressed?

    # Variable to check if movement occurred
    li s10, 0               # movement flag (0 = no, 1 = yes)

    # Process horizontal movement
    la a0, emoji_x
    lw a1, 0(a0)            # load current x
    la a2, prev_x
    lw a3, 0(a2)            # load previous x

    beqz t0, check_right    # if LEFT = 0, check right
    addi a1, a1, -1         # move left
    bltz a1, limit_left     # if < 0, clamp to 0
    j store_x
limit_left:
    li a1, 0
    
    # The following 3 lines prevent redrawing the sprite when colliding with a wall,
    # which would cause flickering. However, they were commented out because while they 
    # remove flickering when attempting to cross walls, the X axis continues incrementing 
    # if more than one D-pad button is pressed. Example: pressing UP and RIGHT together. 
    # Even if blocked upwards, holding RIGHT will continue incrementing X. When UP is released, 
    # the sprite will jump to a new X position very noticeably.
    #sw a1, 0(a0)            # store new X position
    #li s10, 1               # mark that movement occurred
    #j skip_draw             # skip redraw to avoid flickering
    
    j store_x

check_right:
    beqz t1, check_vertical # if RIGHT = 0, check vertical
    addi a1, a1, 1          # move right
    li t4, 19               # max X limit
    bgt a1, t4, limit_right
    j store_x
    
limit_right:
    li a1, 20              # 35-15 = 20 pixels
    
    #sw a1, 0(a0)            # store new X position
    #li s10, 1               # mark that movement occurred
    #j skip_draw             # skip redraw to avoid flickering
    
    j store_x

store_x:
    sw a1, 0(a0)            # store new X position
    li s10, 1               # mark that movement occurred

check_vertical:
    # Process vertical movement
    la a0, emoji_y
    lw a1, 0(a0)            # load current y
    la a2, prev_y
    lw a3, 0(a2)            # load previous y

    beqz t2, check_down     # if UP = 0, skip
    addi a1, a1, -1         # move up
    bltz a1, limit_up       # clamp if < 0
    j store_y
limit_up:
    li a1, 0
    
    #sw a1, 0(a0)            # store new Y position
    #li s10, 1               # mark that movement occurred
    #j skip_draw             # skip redraw to avoid flickering
    
    j store_y

check_down:
    beqz t3, check_movement # if DOWN = 0, skip
    addi a1, a1, 1          # move down
    li t4, 9                # max Y limit (assuming 32x32 matrix)
    bgt a1, t4, limit_down
    j store_y
limit_down:
    li a1, 9                # 25-16 = 9
    
    #sw a1, 0(a0)            # store new Y position
    #li s10, 1               # mark that movement occurred
    #j skip_draw             # skip redraw to avoid flickering
    
    j store_y

store_y:
    sw a1, 0(a0)            # store new Y position
    li s10, 1               # mark that movement occurred

check_movement:
    # Only redraw if there was movement
    beqz s10, skip_draw     # if no movement, skip drawing

    # Erase previous position (both X and Y)
    mv a0, s0
    la t2, prev_x
    lw t3, 0(t2)            # previous x
    la t4, prev_y
    lw t4, 0(t4)            # previous y
    
    li s8, 0                # row
clear_previous:
    li s9, 0                # column
clear_prev_row:
    # pos = base + ((y_prev+row)*width + (x_prev+col))*4
    add t5, t4, s8
    mul t5, t5, s1
    add t6, t3, s9
    add t5, t5, t6
    slli t5, t5, 2
    add t5, s0, t5
    
    # Only erase if inside limits
    blt t5, s0, skip_clear
    bge t5, s6, skip_clear
    
    li t0, 0x00FFFFFF       # white background
    sw t0, 0(t5)
    
skip_clear:
    addi s9, s9, 1
    li t6, 16
    bne s9, t6, clear_prev_row

    addi s8, s8, 1
    li t6, 16
    bne s8, t6, clear_previous

    # Draw new position
    la t2, emoji_x
    lw t3, 0(t2)            # load x offset
    la t4, emoji_y
    lw t4, 0(t4)            # load y offset

    li s8, 0                # row
draw_sprite:
    li s9, 0                # column
draw_row:
    # pos = base + ((y+row)*width + (x+col))*4
    add t5, t4, s8
    mul t5, t5, s1
    add t6, t3, s9
    add t5, t5, t6
    slli t5, t5, 2
    add t5, s0, t5
    
    # Verify limits before drawing
    blt t5, s0, skip_draw_pixel
    bge t5, s6, skip_draw_pixel

    # sprite offset
    slli t6, s8, 4
    add t6, t6, s9
    slli t6, t6, 2
    add t6, s7, t6

    lw t0, 0(t6)
    sw t0, 0(t5)

skip_draw_pixel:
    addi s9, s9, 1
    li t6, 16
    bne s9, t6, draw_row

    addi s8, s8, 1
    li t6, 16
    bne s8, t6, draw_sprite

    # Update previous positions
    la t2, emoji_x
    lw t3, 0(t2)
    la t4, prev_x
    sw t3, 0(t4)
    
    la t2, emoji_y
    lw t3, 0(t2)
    la t4, prev_y
    sw t3, 0(t4)

skip_draw:
    # Small delay to reduce flicker
    li a0, 5000
delay_loop:
    addi a0, a0, -1
    bnez a0, delay_loop

    # Repeat cycle
    j main_loop
